---
slug: cs-sync-async-blocking-non-blocking
title: 동기 vs 비동기, 블로킹 vs 논블로킹
tags: [ cs ]
---

# 동기(Synchronous) vs 비동기(Asynchronous)
호출하는 함수의 작업 완료를 기다리는지 여부의 차이가 있습니다. 함수 A가 동기로 함수 B를 호출하면 A는 B의 작업이 완료될 때까지 기다려야 합니다. 따라서 작업이 순차적으로 진행됩니다. 반면, 함수 A가 비동기로 함수 B를 호출하면 A는 B의 작업 완료를 신경 쓰지 않고 따로 동작합니다. 따라서 작업이 순차적으로 진행되지 않습니다.
### 동기(Synchronous)
<mark>작업이 순차적으로 실행됨.</mark> 하나의 작업이 끝나야 다음 작업이 실행됨.
### 비동기(Asynchronous)
<mark>작업이 독립적으로 실행됨.</mark> 하나의 작업이 끝나지 않아도 다른 작업이 시작될 수 있음.

## ✔️ 블로킹(Blocking) vs 논블로킹(Non-Blocking)
### 블로킹(Blocking)
작업이 완료될 때까지 <mark>현재 스레드가 멈춰서 기다림</mark>
### 논블로킹(Non-Blocking)
작업이 완료되지 않아도 <mark>현재 스레드가 계속 실행됨</mark>

## ✔️ 블로킹과 동기는 어떤 차이가 있을까? 🤔
두 개념은 유사하면서도 다른데요. 동기 호출에서는 호출된 함수가 작업을 완료할 때까지 <mark>호출한 함수가 기다립니다.</mark> 즉, 작업이 순차적으로 진행되는 것을 의미합니다. 반면, 블로킹은 함수가 호출된 후, 호출한 함수의 결과를 기다리기 위해 <mark>실행을 멈추는 상태를 의미</mark>합니다. 즉, 제어권이 반환되지 않고 대기하는 상황입니다.

## ✔️ 스프링에서 비동기 처리는 어떻게 하며 무엇을 주의해야 하나요?
스프링에서는 `@Async` 어노테이션을 사용하여 비동기 처리를 수행할 수 있습니다. 해당 어노테이션을 사용하기 위해서는 몇 가지 주의할 부분이 있는데요. 기본적으로 `@Async`가 적용된 메서드에서 발생하는 예외는 호출자에게 전파되지 않습니다. 비동기 메서드에서 예외를 정상적으로 처리하기 위해서는 별도의 비동기 예외 처리기를 사용해야 합니다. 또한, <mark>`@Async` 어노테이션은 프록시 기반으로 동작하기 때문에 같은 클래스 내부에서 직접 호출하는 경우 별도의 스레드에서 메서드가 실행되지 않습니다.</mark> 그리고, <mark>비동기 메서드 내에서 생성한 트랜잭션은 상위 트랜잭션과 무관한 생명주기를 가집니다.</mark>