---
slug: db-normalization
title: 데이터베이스 정규화
tags: [ db ]
---

데이터베이스에서 `정규화(Normalization)`는 테이블을 정리하여 중복 데이터를 최소화하고, 데이터 무결성을 보장하는 과정을 의미합니다. 이를 통해 데이터 저장 용량을 줄이고, 삽입·갱신·삭제 이상(Anomaly) 현상을 해결할 수 있습니다. 정규화는 여러 단계가 존재하며, 대표적으로 `1 정규화(1NF)`, `2 정규화(2NF)`, `3 정규화(3NF)`, `BCNF`가 있습니다.

# 정규화 (Normalization)
## ✔️ 1NF (First Normal Form)
테이블 컬럼의 값이 원자값(Atomic Value)을 가지도록 정리하는 것을 의미합니다.
### 핵심 요건
| 요건             | 설명                                          |
|------------------|---------------------------------------------|
| 원자성(Atomicity) | 각 컬럼은 **하나의 값만 가져야 함** (리스트, 배열, 콤마 구분값 불가) |
| 반복 컬럼 금지     | phone1, phone2 같은 **중복되는 컬럼 그룹은 허용되지 않음**   |
| 테이블 구조 평탄화 | **테이블 내 셀은 스칼라(단일) 값으로 구성**되어야 함            |
| 행으로 분리        | 하나의 컬럼이 여러 값을 가지면 **여러 행으로 나누어 표현**해야 함     |

### ❌ 1NF 위반
| `학생ID` | `이름`   | `전화번호`                         |
|--------|--------|----------------------------------|
| 1      | 홍길동 | 010-1234-5678, 010-9876-5432     |
| 2      | 김영희 | 010-2222-3333                    |

전화번호 컬럼에 복수 개의 값이 들어 있음 → 비원자적 (1NF 위반)

### ✅ 1NF 적용
| `학생ID` | `이름`   | `전화번호`       |
|--------|--------|----------------|
| 1      | 홍길동 | 010-1234-5678  |
| 1      | 홍길동 | 010-9876-5432  |
| 2      | 김영희 | 010-2222-3333  |

<mark>**각 셀은 하나의 원자값만 포함하고, 여러 전화번호는 행을 나눠서 표현**</mark>

## ✔️ 2NF (Second Normal Form)
1 정규화를 진행한 테이블에서 완전 함수 종속을 만족할 수 있도록 테이블을 분해하는 것인데요. 쉽게 표현하자면, <mark>**기본 키의 일부에만 종속된 속성이 없도록 분해하는 것**</mark>을 의미합니다. A 속성을 통해서 B 속성의 값이 유일하게 정해지는 관계에서 A를 결정자라고 합니다.

1 정규형(1NF)을 만족한 상태에서, 부분 함수 종속(Partial Dependency)을 제거하는 정규화 단계입니다.
1NF를 만족하고, 모든 비프라이머리 속성이 기본키의 전체에 완전 종속해야 합니다. 즉, <mark>**기본키의 일부만으로 결정되는 컬럼이 없어야**</mark> 합니다.

### ❌ 2NF 위반 (1NF는 만족)
#### 학생 테이블
| `학생ID` | `이름`   | `전화번호`       |
|--------|--------|----------------|
| 1      | 홍길동 | 010-1234-5678  |
| 1      | 홍길동 | 010-9876-5432  |
| 2      | 김영희 | 010-2222-3333  |
* 기본키: (`학생ID`, `전화번호`)
* `이름`은 `학생ID`에만 종속됨 (부분 함수 종속 발생 → 2NF 위반)

### ✅ 2NF 적용: 테이블 분해
#### 1) 학생 테이블 (`학생ID` → `이름`)
`이름`은 `학생ID`에만 의존 (완전 함수 종속) → 학생 테이블로 분리

| `학생ID` | `이름`   |
|--------|--------|
| 1      | 홍길동 |
| 2      | 김영희 |

#### 2) 학생-전화번호 테이블 (`학생ID` ↔ `전화번호`)
`전화번호`는 여러 개일 수 있으므로 별도 테이블에서 관리

| `학생ID` | `전화번호`       |
|--------|----------------|
| 1      | 010-1234-5678  |
| 1      | 010-9876-5432  |
| 2      | 010-2222-3333  |

## ✔️ 3NF (Third Normal Form)
2 정규화를 진행한 테이블에서 이행적 종속을 제거하기 위해 테이블을 분해하는 것을 의미합니다. A가 B를 결정하고, B가 C를 결정하는 경우에는 A가 C의 결정자가 되는데요. 이를 이행적 종속이라고 합니다. 3NF을 만족하기 위해서는 이행적 종속이 제거되도록 테이블을 분리해야 합니다.

릴레이션 R이 3NF를 만족하려면, 다음 두 조건 중 하나라도 만족해야 합니다.  
모든 함수 종속 X → Y에 대해,
1) X가 후보키(Candidate Key)이어야 합니다.
2) Y가 <mark>**기본 속성(Prime Attribute: 후보키에 포함된 속성)**</mark>이어야 합니다.

### ❌ 3NF 위반 (2NF는 만족)
#### 학생 테이블
| `학생ID` | `학과ID` | `학과명`   |
|--------|--------|-------|
| 1      | C01    | 컴퓨터공학 |
| 2      | C02    | 전자공학  |
* 기본키: `학생ID`
* `학과명`은 `학생ID` → `학과ID` → `학과명`으로 이행적 종속
* `학과명`은 `학과ID`로 직접 결정되는 값이므로 3NF 위반

학생이 “컴퓨터공학과”라고 해서 학생 테이블에 `학과명`을 같이 넣으면  
나중에 `학과명`이 “컴퓨터공학 → 인공지능공학”으로 바뀔 경우, 여러 학생 테이블 행을 모두 수정해야 합니다.

### ✅ 3NF 적용: 테이블 분해
#### 1) 학생 테이블
| 학생ID | 학과ID |
|--------|--------|
| 1      | C01    |
| 2      | C02    |

#### 2) 학과 테이블
| 학과ID | 학과이름   |
|--------|------------|
| C01    | 컴퓨터공학 |
| C02    | 전자공학   |

## ✔️ BCNF (Boyce-Codd Normal Form)
3 정규화를 진행한 테이블의 <mark>**모든 결정자가 반드시 후보키가 될 수 있도록 테이블을 분해하는 것**</mark>을 의미합니다. BCNF를 만족하기 위해서는 후보키가 아닌 결정자가 존재하지 않도록 테이블을 분리해야 합니다.

릴레이션이 BCNF에 속하려면, 모든 함수적 종속 X → Y에 대해 X가 반드시 후보키여야 합니다.  
즉, X가 후보키가 아닌데도 Y를 결정하는 경우가 있다면 BCNF를 만족하지 못합니다.

### 3NF와의 차이
* 3NF는 이행적 종속 제거가 핵심이며, X가 후보키가 아니어도 Y가 <mark>**기본 속성(Prime Attribute: 후보키에 포함된 속성)**</mark>이면 OK.
* 반면 BCNF는 X가 반드시 후보키여야 하므로 더 강한 제약을 가짐.

### ❌ BCNF 위반 (3NF는 만족)
#### 학생 테이블
| `과목` | `교수` | `교재`       |
|------|------|------------|
| CS101 | 김교수  | C언어 기초     |
| CS102 | 이교수  | Java 완전 정복 |
| CS101 | 김교수  | C언어 기초     |
* 후보키: (`과목`, `교수`)
* (`과목`, `교수`) → `교재` : `교재`는 후보키(`과목`, `교수`)에 따라 결정됨 (3NF, BCNF 만족)
* `교수` → `과목` : `교수`마다 가르치는 `과목`이 하나로 고정되어 있음 (<mark>`과목`은 기본 속성이므로 3NF 만족</mark>, `교수`는 후보키가 아니므로 BCNF 위반)

### ✅ BCNF 적용: 테이블 분해
#### 1) 교수 테이블
| `교수` | `과목`  |
|------|-------|
| 김교수  | CS101 |
| 이교수  | CS102 |
* 후보키: `교수` 
* `교수` → `과목` (함수 종속)

#### 2) 교재 테이블
| `과목`  | `교재`       |
|-------|------------|
| CS101 | C언어 기초     |
| CS102 | Java 완전 정복 |
* 후보키: `과목`
* `과목` → `교재` (함수 종속)

## 📌 데이터베이스 키의 종류
| 이름                  | 설명                                                                 |
|---------------------|--------------------------------------------------------------------|
| 기본 키 (Primary Key)  | 각 레코드를 유일하게 식별하는 키 (null을 허용하지 않음)                                 |
| 후보 키 (Candidate Key) | 기본 키로 사용될 수 있는 속성들의 집합. 기본 키는 후보 키 중 하나 (유일성 조건을 만족하는 모든 키: 단일키/복합키) |
| 대체 키 (Alternate Key) | 후보 키 중 기본 키로 선택되지 않은 나머지 키                                         |
| 복합 키 (Composite Key) | 두 개 이상의 컬럼으로 구성된 키                                                 |
| 외래 키 (Foreign Key)  | 다른 테이블의 기본 키를 참조하는 키                                               |
| 슈퍼 키 (Super Key)      | 유일성을 만족하는 속성들의 집합 (후보 키보다 더 많은 속성을 포함할 수 있음)                       |
| 자연 키 (Natural Key)        | 실제 데이터에 기반한 키 (예: 주민번호, 이메일 등)                                     |
| 인공 키 (Surrogate Key)      | 시스템이 생성한 의미 없는 유일 식별자 (예: 자동 증가 숫자)                                |


# 역정규화 (Denormalization)
역정규화(Denormalization) 는 정규화된 데이터베이스에서 <mark>**쓰기 성능을 희생하고 읽기 성능을 향상하기 위해 사용되는 전략**</mark>입니다. 예를 들어, 전체 게시글의 수나 좋아요의 수를 계산해 특정 컬럼에 저장해서 읽기 성능을 항상 시킬 수 있습니다. 역정규화된 데이터베이스에서는 데이터의 중복을 허용하기 때문에 데이터의 일관성을 맞추기 위한 추가적인 작업이 필요합니다.

정규화를 통해 분해했던 테이블들을 다시 통합하거나 중복 데이터를 의도적으로 추가하는 작업입니다.  
→ <mark>**복잡한 조인 없이 빠르게 데이터를 조회하기 위해 사용**</mark>합니다.

⚠️ 주의할 점  
쓰기 작업이 많고 중복 데이터가 많아지면 동기화가 복잡해지므로, 보통 <mark>**읽기 위주 시스템(예: 검색, 리포트 시스템)에서 활용**</mark>됩니다.

| 구분         | 정규화 (Normalization)                   | 역정규화 (Denormalization)                  |
|--------------|-------------------------------------------|----------------------------------------------|
| 목적         | 데이터 중복 제거, 무결성 유지              | 조회 성능 향상, 조인 최소화                  |
| 테이블 수    | 많아짐                                     | 줄어듦 또는 컬럼/데이터 중복 발생             |
| 유지보수     | 쉬움 (수정 시 한 곳만 수정하면 됨)          | 어려움 (중복된 데이터의 일관성 유지 필요)     |
| 조회 성능    | 느릴 수 있음 (조인이 많아짐)               | 빠름 (조인 없이도 필요한 정보 바로 조회 가능) |
| 저장 공간    | 적음                                       | 많아짐 (중복 데이터로 인해)                   |
| 데이터 무결성| 높음                                       | 낮아질 수 있음 (중복으로 인해 불일치 가능성)  |