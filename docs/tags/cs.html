<!doctype html>
<html lang="ko" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-tags-doc-list-page" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">61개 문서가 &quot;Computer Science&quot; 태그에 분류되었습니다 | 조이 언어발달센터</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://johnycho.github.io/joylangcenter/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://johnycho.github.io/joylangcenter/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://johnycho.github.io/joylangcenter/docs/tags/cs"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" property="og:title" content="61개 문서가 &quot;Computer Science&quot; 태그에 분류되었습니다 | 조이 언어발달센터"><meta data-rh="true" name="description" content="Computer Science tag description"><meta data-rh="true" property="og:description" content="Computer Science tag description"><meta data-rh="true" name="docusaurus_tag" content="doc_tag_doc_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="doc_tag_doc_list"><link data-rh="true" rel="icon" href="/joylangcenter/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://johnycho.github.io/joylangcenter/docs/tags/cs"><link data-rh="true" rel="alternate" href="https://johnycho.github.io/joylangcenter/docs/tags/cs" hreflang="ko"><link data-rh="true" rel="alternate" href="https://johnycho.github.io/joylangcenter/docs/tags/cs" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://NAZXBH587R-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/joylangcenter/blog/rss.xml" title="조이 언어발달센터 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/joylangcenter/blog/atom.xml" title="조이 언어발달센터 Atom Feed">




<link rel="search" type="application/opensearchdescription+xml" title="조이 언어발달센터" href="/joylangcenter/opensearch.xml">
<script src="https://johny-dev.disqus.com/count.js" async id="dsq-count-scr"></script><link rel="stylesheet" href="/joylangcenter/assets/css/styles.81c9168a.css">
<script src="/joylangcenter/assets/js/runtime~main.ab6a0457.js" defer="defer"></script>
<script src="/joylangcenter/assets/js/main.3d24ac68.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="https://github.com/johnycho.png"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="메인" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="사이드바 펼치거나 접기" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/joylangcenter/"><div class="navbar__logo"><img src="https://github.com/johnycho.png" alt="Johny Dev Logo" class="custom-navbar-logo themedComponent_mlkZ themedComponent--light_NVdE"><img src="https://github.com/johnycho.png" alt="Johny Dev Logo" class="custom-navbar-logo themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">조니의 개발 블로그</b></a><div class="navbar__item dropdown dropdown--hoverable"><a class="navbar__link" aria-haspopup="true" aria-expanded="false" role="button" href="/joylangcenter/docs/intro">Docs</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/joylangcenter/docs/intro">All Docs</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/joylangcenter/docs/tags">Tags</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a class="navbar__link" aria-haspopup="true" aria-expanded="false" role="button" href="/joylangcenter/blog">Blog</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/joylangcenter/blog">All Posts</a></li><li><a class="dropdown__link" href="/joylangcenter/blog/archive">Archive</a></li><li><a class="dropdown__link" href="/joylangcenter/blog/tags">Tags</a></li></ul></div></div><div class="navbar__items navbar__items--right"><a href="https://github.com/johnycho" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link navbar-github-logo"></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 어두운 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 어두운 모드)" aria-live="polite" aria-pressed="true"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="검색 (Command+K)"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">검색</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><main class="col col--8 col--offset-2"><header class="margin-bottom--xl"><h1>61개 문서가 &quot;Computer Science&quot; 태그에 분류되었습니다</h1><p>Computer Science tag description</p><a href="/joylangcenter/docs/tags">모든 태그 보기</a></header><section class="margin-vert--lg"><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-call-by"><h2>Call By Value와 Call By Reference</h2></a><p>특정 메서드를 호출하는 경우 인자로 전달하는 방법은 크게 2가지가 존재하는데요. 값에 의한 호출(Call By Value), 참조에 의한 호출(Call By Reference)이 이에 해당됩니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/db/db-cap-theorem"><h2>CAP 정리 (= 브루어(Brewer)의 정리)</h2></a><p>CAP 정리 (= 브루어(Brewer)의 정리)는 분산 데이터베이스 시스템이 CAP 중 2개의 속성만을 제공할 수 있다는 이론입니다. CAP 정리에 따르자면, 일관성(Consistency), 가용성(Availability), 분할 내성(Partition Tolerance) 등 3가지 속성을 모두 만족하는 분산 데이터베이스 시스템은 존재하지 않습니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-ci-cd-pipeline"><h2>CI/CD 파이프라인</h2></a><p>✔️ 지속적 통합 (Continuous Integration)</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-network-timeout"><h2>Connection Timeout, Socket Timeout, Read Timeout의 차이점</h2></a><p>✔️ Connection Timeout</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-cors"><h2>CORS(Cross Origin Resource Sharing)</h2></a><p>CORS(Cross Origin Resource Sharing)는 출처가 다른 곳의 리소스를 요청할 때 접근 권한을 부여하는 메커니즘입니다. 리소스를 주고받는 두 곳의 출처가 다르면 출처가 교차한다고 합니다. 이때 출처는 URL뿐만 아니라 프로토콜과 포트까지 포함됩니다. 만약 클라이언트의 출처가 허용되지 않았다면 CORS 에러가 발생할 수 있습니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-cpu-scheduling"><h2>CPU 스케줄링</h2></a><p>CPU 스케줄링은 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 의미합니다. 만약 CPU 스케줄링이 없다면, 반드시 실행되어야 할 프로세스들이 실행되지 못할 수 있으며, 당장 급하지 않은 프로세스가 실행되는 등 무질서한 상태가 발생할 수 있습니다. CPU 스케줄링은 선점형과 비선점형 방식으로 구현할 수 있으며, 다양한 스케줄링 알고리즘이 존재합니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-cqrs-pattern"><h2>CQRS(명령 쿼리 책임 분리) 패턴</h2></a><p>시스템은 크게 상태 변경과 조회 기능을 제공하는데요. 주문 취소, 결제 기능은 상태 변경에 해당되며, 주문서 조회, 사용자 조회 등이 조회에 해당됩니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-dns"><h2>DNS (Domain Name System)</h2></a><p>DNS(Domain Name System) 는 웹사이트의 도메인 주소를 IP 주소로 변환하는 시스템입니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-graceful-shutdown"><h2>Graceful Shutdown (우아한 종료)</h2></a><p>✔️ Graceful Shutdown (우아한 종료)</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-https"><h2>HTTP vs HTTPS</h2></a><p>✔️ HTTP(Hypertext Transfer Protocol)</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-http-method-idempotency"><h2>HTTP 메서드의 멱등성</h2></a><p>연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 멱등성이라고 합니다. HTTP 메서드의 멱등성은 동일한 요청을 한번 보내는 것과 여러번 보내는 것이 서로 동일한 효과를 지니며, 서버의 상태도 동일하게 남을 경우에 멱등하다고 이야기할 수 있습니다. 대표적으로 멱등한 메서드는 GET, HEAD, PUT, DELETE, TRACE, OPTIONS 가 있습니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-http-version"><h2>HTTP/1.1과 HTTP/2.0</h2></a><p>✔️ HTTP/1.1</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-ip-address-allocation"><h2>IP 주소 할당 방식</h2></a><p>네트워크에서 호스트에게 IP를 할당하는 방식은 크게 정적 할당 방식과 동적 할당 방식이 존재합니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-jwt"><h2>JWT (Json Web Token)</h2></a><p>JWT(Json Web Token) 은 통신 정보를 JSON 형식을 사용하여 안전하게 전송하기 위해 사용됩니다. JWT는 토큰 자체에 정보가 포함되어 있는 Claim 기반 토큰입니다. 일반적인 애플리케이션에서 JWT는 주로 인증과 인가를 구현하기 위해 사용됩니다. JWT는 헤더, 페이로드, 시그니처로 구분됩니다. 헤더에는 토큰의 암호화 알고리즘이나 타입을 가지며, 페이로드에는 데이터(만료일, 사용자 정보 등)를 가집니다. 시그니처는 헤더와 페이로드가 변조되지 않았는지 판단하기 위해 사용되는데요. 헤더와 페이로드를 비밀 키를 사용하여 헤더에 명시된 암호화 알고리즘으로 암호화하여 시그니처가 만들어집니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-nat"><h2>NAT (Network Address Translation)</h2></a><p>IP 주소는 공인 IP 주소(Public IP Address) 와 사설 IP 주소(Private IP Address) 가 존재합니다. 공인 IP 주소는 고유하며, 사설 IP 주소는 고유하지 않고 특정 사설 네트워크에서만 사용됩니다. 이때, 사설 네트워크는 외부 네트워크에 공개되지 않은 네트워크를 의미합니다. 사설 IP는 일반적으로 라우터가 할당하며, 할당받은 사설 IP 주소는 사설 네트워크 상에서만 유효합니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-prg-pattern"><h2>PRG(Post/Redirect/Get) 패턴</h2></a><p>✔️ PRG 패턴</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-rest"><h2>REST란?</h2></a><p>✔️ REST(Representational State Transfer)</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-tcp-3-way-handshake"><h2>TCP 3-way handshake</h2></a><p>3-way handshake</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-uri-url-urn"><h2>URI, URL, URN의 차이점</h2></a><p>URI, URL, URN</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-virtualization"><h2>가상화(Virtualization)</h2></a><p>✔️ 가상화 (Virtualization)</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-solid-principle"><h2>객체지향 설계 5원칙(SOLID)</h2></a><p>SOLID 원칙은 객체지향 설계 5원칙이라고도 불리며, 각 원칙의 앞 글자를 따서 만들어졌습니다. 객체지향설계의 핵심 중 하나는 의존성을 관리하는 것인데요. 의존성을 잘 관리하기 위해서는 SOLID 원칙을 준수해야 합니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-race-condition"><h2>경쟁 상태 (Race Condition)</h2></a><p>경쟁 상태(Race Condition) 는 두 개 이상의 스레드가 공유 자원에 동시에 접근할 때 스레드 간의 실행 순서에 따라 결과가 달라지는 현상으로, 원자성과 가시성 모두 보장되어야 해결할 수 있습니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-deadlock"><h2>교착 상태(deadlock)</h2></a><p>교착 상태(deadlock) 는 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있어 결과적으로 아무것도 완료되지 못하는 상태를 의미합니다. 가령, A 프로세스가 자원 A를 가지고 자원 B를 필요로 합니다. 그리고, B 프로세스는 자원 B를 가지고 자원 A가 필요할 때 두 개의 프로세스는 교착 상태에 빠져 어느 작업도 진행할 수 없는 상황이 됩니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-ip-addressing"><h2>네트워크 IP 주소 체계</h2></a><p>✔️ 클래스풀 주소 체계 (Classful Addressing)</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-keep-alive"><h2>네트워크 Keep Alive 속성</h2></a><p>Keep Alive는 네트워크 또는 시스템에서 커넥션을 지속해서 유지하기 위해 사용되는 기술이나 설정을 의미합니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-session-based-authentication"><h2>다중 서버 환경의 세션 기반 인증 방식</h2></a><p>다중 서버 환경에서 세션 기반 인증 방식을 사용하는 경우에는 세션 불일치 문제가 발생할 수 있습니다. 만약 서버 A, B를 관리하고 있을 때, 로드밸런서는 사용자의 요청을 상황에 맞게 A, B 중 한 곳으로 전달합니다. 유효한 로그인 요청이 A 서버로 처음 도착하면 사용자에 대한 세션 정보는 A 서버에 저장됩니다. 이후에 해당 사용자의 또 다른 요청이 로드 밸런서에 도착했을 때, B 서버로 도착하게 되면 사용자의 세션 데이터가 존재하지 않기 때문에 요청이 제대로 처리되지 않습니다. 이를 세션 불일치 문제라고 합니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-unit-integration-test"><h2>단위 테스트와 통합 테스트</h2></a><p>단위 테스트</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-single-process-system"><h2>단일 프로세스 시스템</h2></a><p>✔️ 단일 프로세스</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-sync-async-blocking-non-blocking"><h2>동기 vs 비동기, 블로킹 vs 논블로킹</h2></a><p>호출하는 함수의 작업 완료를 기다리는지 여부의 차이가 있습니다. 함수 A가 동기로 함수 B를 호출하면 A는 B의 작업이 완료될 때까지 기다려야 합니다. 따라서 작업이 순차적으로 진행됩니다. 반면, 함수 A가 비동기로 함수 B를 호출하면 A는 B의 작업 완료를 신경 쓰지 않고 따로 동작합니다. 따라서 작업이 순차적으로 진행되지 않습니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-concurrency-and-parallelism"><h2>동시성과 병렬성</h2></a><p>Concurrency and Parallelism</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-disk-access-time"><h2>디스크 접근 시간(Disk Access Time)</h2></a><p>일반적으로 단일-헤드 디스크 시스템에서 특정 데이터 블록(하나 이상의 섹터로 이루어짐)을 읽거나 쓰기 위해서는</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-log-and-metric"><h2>로그와 메트릭</h2></a><p>✔️ 로그</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-load-balancing"><h2>로드 밸런싱</h2></a><p>로드 밸런싱이란 애플리케이션을 지원하는 리소스 풀에 들어오는 네트워크 트래픽(들어오는 요청)을 균등하게 분산하는 것을 의미합니다. 이를 수행하는 로드 밸런서는 애플리케이션 서버 앞단에 위치하며 클라이언트 요청을 지시하고 제어합니다. 이를 통해서 애플리케이션의 가용성, 확장성, 보안 및 성능을 확보할 수 있습니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-proxy"><h2>리버스 프록시와 포워드 프록시의 차이점</h2></a><p>✔️ 포워드 프록시(Forward Proxy)</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-multi-tasking-system"><h2>멀티 태스킹 시스템의 한계</h2></a><p>✔️ 멀티 태스킹(Multi-Tasking) 시스템의 문제</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-zero-downtime-deployment"><h2>무중단 배포 (Zero-Downtime Deployment)</h2></a><p>무중단 배포(Zero-Downtime Deployment) 는 서비스에 다운 타임이 발생하지 않으면서, 새로운 버전의 애플리케이션을 서버에 배포하는 것을 의미합니다. 무중단 배포 패턴에는 대표적으로 순차적으로 배포하는 롤링 배포, 전체 서버를 통째로 바꾸는 블루/그린 배포, 트래픽을 순차적으로 이동시키는 카나리 배포가 존재합니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-csrf"><h2>사이트 간 요청 위조(Cross-site Request Forgery, CSRF) 공격</h2></a><p>사이트 간 요청 위조(Cross-site Request Forgery, CSRF) 공격은 사용자가 자신의 의지와 상관없이 공격자가 의도한 행위를 특정 웹사이트에 요청하도록 하는 것을 의미합니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-ssr-and-csr"><h2>서버 사이드 렌더링(SSR)과 클라이언트 사이드 렌더링(CSR)</h2></a><p>✔️ 서버 사이드 렌더링(SSR)</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-computing-resources"><h2>스레드, 프로세스, 코어의 수는 많을 수록 좋을까?</h2></a><p>스레드, 프로세스, 코어의 수가 많을수록 시스템 성능이 향상된다고 생각할 수 있지만, 실제로는 그렇지 않을 확률이 큽니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-scale-up-out"><h2>스케일 아웃과 스케일 업</h2></a><p>기존 개발하고 있던 서비스의 서버가 한계에 도달하는 경우, 스케일 업(Scale-Up) 혹은 스케일 아웃(Scale-Out) 을 고려할 수 있습니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-stack-queue"><h2>스택(Stack) 자료 구조</h2></a><p>✔️ 스택 (Stack)</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-async-integration"><h2>시스템 간 비동기 연동 방식</h2></a><p>분리된 시스템 간의 비동기 연동은 시스템 간의 결합도를 낮출 수 있으며, 호출된 시스템의 응답을 기다리지 않으므로 더욱 빨리 사용자의 요청에 응답할 수 있다는 장점이 있습니다. 비동기 연동 방식으로 메시징 시스템 활용, 데이터베이스 활용, CDC 활용 방식이 있습니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-system-call"><h2>시스템 콜 (System Call)</h2></a><p>운영체제는 사용자가 실행하는 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지해 자원을 보호합니다. 왜냐하면, 프로그램이 CPU, 메모리, 하드 디스크에 마음대로 접근하고 조작할 수 있다면, 자원이 무질서하게 관리 될 수 있으며 한 프로그램의 실수가 전체 컴퓨터에 영향을 주기 때문입니다. 운영체제는 프로그램들이 자원에 접근하려 할 때 오직 자신을 통해서만 접근하도록 하여 자원을 보호합니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-algorithm-complexity"><h2>알고리즘 복잡도 측정</h2></a><p>하나의 문제를 해결하는 여러 알고리즘이 존재할 수 있습니다. 그리고, 개발자는 성능을 평가하여 하나를 결정해야 합니다. 이때, 코드가 실행될 때 걸리는 정확한 시간을 측정하는 방법으로 속도를 비교할 수 있습니다. 하지만, 실행 시간은 기계에 의존적이며 대안으로 나온 알고리즘들이 모두 짧은 시간 내로 수행되어 비교가 어려울 수 있습니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-continuous-memory-allocation"><h2>연속 메모리 할당 기법 (Continuous Memory Allocation)</h2></a><p>연속 메모리 할당 기법(Continuous Memory Allocation) 은 운영체제가 프로세스에 연속적인 메모리 공간을 할당하는 방법을 의미합니다. 연속 메모리 할당 기법을 사용하면, 하나의 프로세스는 메모리 주소 공간에서 연속적으로 존재하게 됩니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-third-party-sync-failure"><h2>외부 API 장애 대응</h2></a><p>외부 서비스 장애로 인해 응답이 오래 걸린다고 했을 때, 외부 API 응답으로 대기하는 자원들이 운영 서버 내부에 쌓이면서 성능에 악영향을 줄 수 있습니다. 이를 해결하기 위한 가장 기본적인 방법은 타임아웃을 설정하는 것입니다. 크게 타임아웃에는 커넥션 타임아웃과 리드 타임아웃, HTTP 커넥션 풀 타임아웃을 설정해 볼 수 있습니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-web-process"><h2>웹 브라우저에 URL 입력하면 일어나는 일</h2></a><p>예를 들어 사용자가 www.google.com을 입력하면, 브라우저는 HTTP 프로토콜을 사용해 구글 웹 서버와 통신하려고 합니다. HTTP는 OSI 7계층 중 애플리케이션 계층에서 동작하는 프로토콜입니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-ws-vs-was"><h2>웹 서버와 WAS(Web Application Server)</h2></a><p>✔️ 웹 서버 (Web Server)</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-cohesion-and-coupling"><h2>응집도와 결합도</h2></a><p>✔️ 응집도(Cohesion)</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-first-class-collection"><h2>일급 컬렉션</h2></a><p>하나의 컬렉션을 감싸는 클래스를 만들고, 해당 클래스에서 컬렉션과 관련된 비즈니스 로직을 관리하는 패턴을 말합니다. 아래 코드 중에서 Order의 List 자료구조를 감싼 Orders가 일급 컬렉션의 예시입니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-strategy-pattern"><h2>전략 패턴 (Strategy Pattern)</h2></a><p>전략 패턴(Strategy Pattern)은 객체의 행위를 동적으로 변경하고 싶은 경우, 코드를 직접 수정하는 것이 아닌 추상화된 전략의 구현만을 바꿔 객체의 행위를 변경하는 디자인 패턴입니다. 자바 언어의 요소와 함께 설명해 드리자면, 객체의 행위를 Interface로 정의하고, Interface의 메서드를 구현하는 구현체들을 주입하는 것이 전략 패턴의 대표적인 형태입니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-cdn"><h2>컨텐츠 전송 네트워크 (Content Delivery Network, CDN)</h2></a><p>컨텐츠 전송 네트워크(Content Delivery Network, CDN) 은 전 세계에 분산된 서버 네트워크며, 사용자와 물리적으로 가까운 위치에서 정적 컨텐츠(혹은 동적 컨텐츠)를 제공하여 서버 과부하를 방지하고 통신 지연을 단축합니다. CDN은 통신에 참여하는 호스트 간에 중간 서버를 두어 성능을 향상합니다. 대표적인 CDN 서비스로는 CloudFront, CloudFlare 등이 있습니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-code-coverage"><h2>코드 커버리지 (Code Coverage)</h2></a><p>✔️ 코드 커버리지 (Code Coverage)</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-infrastructure-as-code"><h2>코드형 인프라 (Infrastructure as Code, IaC)</h2></a><p>코드형 인프라(Infrastructure as Code, IaC) 는 수동 프로세스 대신 코드를 통해 인프라를 프로비저닝하고 관리하는 방법입니다. 기존의 수동 설정 방식은 반복 작업이 많고 휴먼 에러가 발생하기 쉬우며, 인프라 설정을 별도로 문서화해 관리해야 하는 번거로움이 있습니다. IaC는 이러한 문제를 해결하기 위해 등장했으며, 인프라를 코드로 관리함으로써 일관성을 보장하고 운영 효율성을 높일 수 있습니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-test-double"><h2>테스트 더블 (Test Double)</h2></a><p>테스트 더블(Test Double) 은 테스트 코드에서 실제 객체 대신 사용하는 대체 객체를 의미합니다. 실전에서 사용하는 객체를 테스트 환경에 맞게 “더블”로 바꿔치기해서 테스트를 수행할 수 있도록 도와줍니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-trie"><h2>트라이(Trie) 자료 구조</h2></a><p>✔️ 트라이 (Trie) 자료 구조란?</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/db/db-transactional-outbox-pattern"><h2>트랜잭셔널 아웃박스 패턴 (Transactional Outbox Pattern)</h2></a><p>트랜잭셔널 아웃박스 패턴(Transactional Outbox Pattern) 은 분산 시스템에서 단일 작업에 데이터베이스 쓰기 작업과 메시지 혹은 이벤트 발행이 모두 포함된 경우 발생하는 이중 쓰기 문제를 해결하기 위해서 사용할 수 있습니다. 예를 들어, 다음과 같은 코드가 존재한다고 가정하겠습니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-context-switch"><h2>프로세스와 스레드 컨텍스트 스위칭</h2></a><p>✔️ 컨텍스트 스위칭(Context Switching)이란?</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-functional-programming"><h2>함수형 프로그래밍 (Functional Programming)</h2></a><p>객체지향 패러다임과 마찬가지로 하나의 프로그래밍 패러다임으로서,</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-hash-collision"><h2>해시 충돌</h2></a><p>해시(Hash) 자료 구조는 키-값 쌍으로 이루어진 데이터 구조로 키를 이용해 값을 O(1) 시간 복잡도로 찾을 수 있습니다. 해시 자료 구조는 키를 해시 함수에 넣어서 나오는 결과를 기반으로 값을 관리하는데요. 해시 함수는 다른 키를 사용해도 같은 결과가 나오는 경우가 존재합니다. 이를 해시 충돌(Hash Collision) 이라고 합니다.</p></article><article class="margin-vert--lg"><a href="/joylangcenter/docs/cs/cs-network-switching"><h2>회선 교환 방식과 패킷 교환 방식</h2></a><p>✔️ 회선 교환 방식 (Circuit Switching)</p></article></section></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Johny Cho. All rights reserved.</div></div></div></footer></div>
</body>
</html>